use indoc::writedoc;
use ssbh_data::anim_data::GroupType;
use ssbh_data::matl_data::{
    BlendFactor, CullMode, FillMode, MagFilter, MaxAnisotropy, MinFilter, ParamId, WrapMode,
};
use ssbh_data::skel_data::BillboardType;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;
use strum::VariantNames;

fn write_enum_pymethods<W: Write>(w: &mut W, class_name: &str, enum_path: &str, variants: &[&str]) {
    writeln!(w, "#[pymethods]").unwrap();
    writeln!(w, "impl {} {{", class_name).unwrap();

    // TODO: Better indendation.
    writedoc!(
        w,
        r#"
        fn __repr__(&self) -> String {{
            self.py_repr()
        }}
        "#
    )
    .unwrap();

    let cmp = "pyo3::basic::CompareOp";
    writedoc!(
        w,
        r#"
            fn __richcmp__(&self, other: Self, op: {cmp}) -> PyResult<bool> {{
                match op {{
                    {cmp}::Lt => Ok(self.value < other.value),
                    {cmp}::Le => Ok(self.value <= other.value),
                    {cmp}::Eq => Ok(self.value == other.value),
                    {cmp}::Ne => Ok(self.value != other.value),
                    {cmp}::Gt => Ok(self.value > other.value),
                    {cmp}::Ge => Ok(self.value >= other.value),
                }}
            }}
        "#
    )
    .unwrap();

    for variant in variants {
        let function_name = variant.to_lowercase();
        writedoc!(
            w,
            r#"
                #[classattr]
                #[pyo3(name = "{variant}")]
                pub fn {function_name}() -> {class_name} {{
                    {enum_path}::{class_name}::{variant}.into()
                }}

            "#
        )
        .unwrap();
    }

    // TODO: This would be cleaner as part of a macro?
    // TODO: Multiple pymethods blocks?
    // usize -> enum
    writedoc!(
        w,
        r#"
            #[staticmethod]
            pub fn from_value(value: usize) -> Option<{class_name}> {{
                {enum_path}::{class_name}::from_repr(value).map(Into::into)
            }}

        "#
    )
    .unwrap();

    // String -> enum
    writedoc!(
        w,
        r#"
            #[staticmethod]
            pub fn from_str(value: &str) -> Option<{class_name}> {{
                {enum_path}::{class_name}::from_str(value).map(Into::into).ok()
            }}
        "#
    )
    .unwrap();

    writeln!(w, "}}").unwrap();
}

fn main() {
    // TODO: When will this be rerun?
    // println!("cargo:rerun-if-changed=src/matl_data.rs");

    // TODO: Combine this with defining the enum class itself?
    generate_enum_file(
        "src/matl_data/enums.rs",
        "ssbh_data::matl_data",
        &[
            ("ParamId", ParamId::VARIANTS),
            ("BlendFactor", BlendFactor::VARIANTS),
            ("FillMode", FillMode::VARIANTS),
            ("CullMode", CullMode::VARIANTS),
            ("WrapMode", WrapMode::VARIANTS),
            ("MinFilter", MinFilter::VARIANTS),
            ("MagFilter", MagFilter::VARIANTS),
            ("MaxAnisotropy", MaxAnisotropy::VARIANTS),
        ],
    );

    generate_enum_file(
        "src/anim_data/enums.rs",
        "ssbh_data::anim_data",
        &[("GroupType", GroupType::VARIANTS)],
    );

    generate_enum_file(
        "src/skel_data/enums.rs",
        "ssbh_data::skel_data",
        &[("BillboardType", BillboardType::VARIANTS)],
    );
}

fn generate_enum_file(file_path: &str, enum_path: &str, enums: &[(&str, &[&str])]) {
    // Make sure the folder exists first.
    let file_path = Path::new(file_path);
    std::fs::create_dir_all(file_path.parent().unwrap()).unwrap();

    let mut f = BufWriter::new(File::create(file_path).unwrap());
    writedoc!(
        &mut f,
        r#"
        // File automatically generated by build.rs.
        // Changes made to this file will not be saved.
        use pyo3::prelude::*;
        use super::*;
        use std::str::FromStr;
    "#
    )
    .unwrap();
    writeln!(&mut f).unwrap();

    for (name, variants) in enums {
        write_enum_pymethods(&mut f, name, enum_path, variants);

        // Each enum uses the same class structure for now.
        writedoc!(
            &mut f,
            r#"
            impl crate::PyiClass for {name} {{
                fn pyi_class() -> String {{
                    "class {name}:\n    name: str\n    value: int".to_string()
                }}
            }}
        "#
        )
        .unwrap();

        // Add a class variable for each enum variant.
        // TODO: Is there a way to differentiate between class and instance variables?
        // HACK: Just use the methods trait to also optionally include class attributes.
        writeln!(&mut f, "impl crate::PyiMethods for {name} {{").unwrap();
        writeln!(&mut f, "    fn pyi_methods() -> String {{").unwrap();

        let class_attributes = variants
            .iter()
            .map(|v| format!("    {v}: ClassVar[{name}]"))
            .collect::<Vec<String>>()
            .join("\n");
        writeln!(
            &mut f,
            r#"        "{class_attributes}

    @staticmethod
    def from_value(value: int) -> Optional[{name}]: ...

    @staticmethod
    def from_str(value: str) -> Optional[{name}]: ...".to_string()"#,
        )
        .unwrap();

        writeln!(&mut f, "    }}").unwrap();
        writeln!(&mut f, "}}").unwrap();
    }
}
